{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>The Event Driven Toolkit (EDT for short) is your swiss army knife for event driven applications, Go edition. Here you find implementation support for common patterns when developing such applications.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>For several years, more than a decade certainly, found myself repeating some patterns for each programming language happened to be using at the time. Go is one of those languages where most recently had to repeat those trusted recipes in.</p>"},{"location":"#why","title":"Why?","text":""},{"location":"#designed-to-improve-code-quality","title":"Designed to improve Code Quality","text":"<p>Having common constructs is a great way to improve your code.</p> <p>Go has very powerful language capabilities for parallelism and exchanging data, like <code>coroutines</code> and <code>channels</code>. Such native language constructs reduce immensely the complexity of some tasks but it is equally easy to produce messy code if there is not some effort made into readability. This library aims for that particular goal: Making code readable, simpler and, consequently, improve the overall Code Quality.</p> <p>\u26a0\ufe0f Disclaimer: There is no hidden claim trying to imply that code produced in this language is prone to get messy. By the contrary, Go is a very elegant language. Newcomers might however, become overwhelmed with some capabilities or use them ineffectively. </p>"},{"location":"#event-hub","title":"Event Hub","text":"<p>This is just one of the Constructs you can find within this library, but it is probably the most important one. By definition, an Event Driven application deals with Publishing and Subscribing events, this Construct fulfils just that.</p>"},{"location":"#consistency","title":"Consistency","text":"<p>What also makes this library special is that most Constructs work well together.</p> <p>\ud83d\udc49 You can control a <code>State Machine</code> state changes by publishing events or even have a task on your application that is blocked until an event is dispatched (using the <code>Expectable</code> construct).</p>"},{"location":"#leveraging-from-go","title":"Leveraging from Go","text":"<p>This library is intended to leverage from Go, not just hide \"features that might look scary for new developers\" under useless abstractions. It is actually important to have a clear understanding of this language capabilities to effectively utilise EDT.</p>"},{"location":"a-golang-primer/","title":"A Golang primer","text":"<p>To make the most out of this library, it's essential to have a solid understanding of Go's capabilities. Familiarity with certain language and standard library features is crucial for achieving this goal.</p> <p>It is out of scope of this document to provide a complete Go tutorial, it is expected that you have some familiarity already or have other means to cover that requirement.</p> <p>This document aims to bring your attention to key aspects only.</p>"},{"location":"a-golang-primer/#functions","title":"Functions","text":"<p>Functions in Go have a key part in the language design philosophy:</p> <ul> <li>Can return multiple values.</li> <li>Are first-class citizens (in short, they are treated as any other data type, thus assignable to a variable).</li> <li>Can be defined as closures, thus capturing surrounding declared variables that can be accessed and modified even after the surrounding function returned.</li> <li>Variable number of arguments with the ellipsis syntax (<code>...</code>).</li> <li>Return values can be named</li> </ul>"},{"location":"a-golang-primer/#coroutines","title":"Coroutines","text":"<p>Coroutines (aka goroutines) are lightweight threads of execution, managed by the Go runtime instead of the OS. Therefore, concurrent programming is natively supported. Communication is commonly achieved with <code>channels</code>.</p> <p>Take the following naive example: <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc foo() {\n    for i := 0; i &lt; 5; i++ {\n        fmt.Println(\"foo\", i)\n        time.Sleep(100 * time.Millisecond)\n    }\n}\n\nfunc bar() {\n    for i := 0; i &lt; 5; i++ {\n        fmt.Println(\"bar\", i)\n        time.Sleep(100 * time.Millisecond)\n    }\n}\n\nfunc main() {\n    // Start the goroutines in parallel\n    go foo()\n    go bar()\n\n    // Naive approach for awaiting the goroutines to finish\n    time.Sleep(1 * time.Second)\n\n    fmt.Println(\"Done\")\n}\n</code></pre></p> <p>The functions <code>foo</code> and <code>bar</code> are executed in parallel, just by utilising the native language <code>go</code> statement.</p> <p>\u26a0\ufe0f Please note that using a <code>time.Sleep</code>, to assume that both functions had enough time to complete, is an improper way of solving the problem. The idea is to avoid including other concepts simultaneously.</p>"},{"location":"a-golang-primer/#closures","title":"Closures","text":"<p>Combined with the fact that functions in Go are first-class citizens, closures are a language feature that bring a lot of power and flexibility. With such capability, it becomes possible to create functions that capture and maintain a state, behave like objects, facilitate functional and concurrency logic.</p> <p>Take the following example, that defines a simple sequencer: <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\nfunc sequencer() func() int {\n    i := 0\n    return func () int {\n        i++\n        return i\n    }\n}\n\nfunc main() {\n    seq1 := sequencer()\n\n    fmt.Println(seq1()) // prints 1\n    fmt.Println(seq1()) // prints 2\n    fmt.Println(seq1()) // prints 3\n\n    seq2 := sequencer()\n    fmt.Println(seq2()) // prints 1\n}\n</code></pre></p> <p>With this library you will often be leveraging from this language feature, by passing anonymous functions over. Such approach will require to follow a certain signature but will simplify integrating your code seamlessly without too much boilerplate or obscure code.</p>"},{"location":"a-golang-primer/#defer","title":"Defer","text":"<p>The <code>defer</code> statement in Go allows you to schedule a function call to be executed later, when the surrounding function completes. It is often used to ensure that some cleanup code is executed after a function completes, regardless of the path that led to the function's exit.</p> <p>Take this revised example where the <code>defer</code> statement is utilised to signal the wait group the function completed its execution:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc foo(wg *sync.WaitGroup) {\n    defer wg.Done()\n    for i := 0; i &lt; 5; i++ {\n        fmt.Println(\"Foo:\", i)\n        time.Sleep(100 * time.Millisecond)\n    }\n}\n\nfunc bar(wg *sync.WaitGroup) {\n    defer wg.Done()\n    for i := 0; i &lt; 5; i++ {\n        fmt.Println(\"Bar:\", i)\n        time.Sleep(100 * time.Millisecond)\n    }\n}\n\nfunc main() {\n    // Define a wait group...\n    var wg sync.WaitGroup\n    // ... with 2 slots\n    wg.Add(2)\n\n    // Start the operations in parallel\n    go foo(&amp;wg)\n    go bar(&amp;wg)\n\n    // Wait for completion\n    wg.Wait()\n\n    fmt.Println(\"Done!\")\n}\n</code></pre> <p>This example is too simple to show the real value of using <code>defer</code>, but it tries to illustrate it's purpose. With this mechanism you can be rest assured that, when the function terminates, the statement will always be executed. A more complex execution pattern, with multiple return points, would show off better the value of this statement (since you would not be hard-pressed, to make sure in each return block, the wait group is signalled properly).</p>"},{"location":"a-golang-primer/#wait-groups","title":"Wait Groups","text":"<p>Wait Groups are a mechanism to allow any other goroutine to wait for a group of goroutines to complete before continuing execution.</p> <p>Take this revised example, where the parallel execution of <code>foo</code> and <code>bar</code> is awaited using this construct: <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc foo(wg *sync.WaitGroup) {\n    for i := 0; i &lt; 5; i++ {\n        fmt.Println(\"Foo:\", i)\n        time.Sleep(100 * time.Millisecond)\n    }\n    wg.Done()\n}\n\nfunc bar(wg *sync.WaitGroup) {\n    for i := 0; i &lt; 5; i++ {\n        fmt.Println(\"Bar:\", i)\n        time.Sleep(100 * time.Millisecond)\n    }\n    wg.Done()\n}\n\nfunc main() {\n    // Define a wait group...\n    var wg sync.WaitGroup\n    // ... with 2 slots\n    wg.Add(2)\n\n    // Start the operations in parallel\n    go foo(&amp;wg)\n    go bar(&amp;wg)\n\n    // Wait for completion\n    wg.Wait()\n\n    fmt.Println(\"Done!\")\n}\n</code></pre></p> <p>You will not likely be often required to rely on Wait Groups interacting with this library. Most of the constructs make your life easier with concurrency or by communicating between them, even if running in the background or in parallel.</p> <p>One use case, however, is if you want to be sure that when publishing an event, into the <code>eventhub.EventHub</code> construct, all subscribers got the chance to execute until completion.</p> <p>\ud83d\udc49 Normally you just fire and forget events, this is just meant for special scenarios where you need to be sure everything finished before continuing.</p> <p>e.g.: <pre><code>func main(){\n    ...\n    wg := hub.Publish(SomeEvent{}, nil)\n\n    // Wait for all subscribers to complete their execution\n    wg.Wait()\n}\n</code></pre></p>"},{"location":"a-golang-primer/#channels","title":"Channels","text":"<p>Channels are thread-safe data structures for communicating between goroutines.</p> <p>Take the following revised example: <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc foo(ch chan&lt;- bool) {\n    for i := 0; i &lt; 5; i++ {\n        fmt.Println(\"Foo:\", i)\n        time.Sleep(100 * time.Millisecond)\n    }\n    ch &lt;- true\n}\n\nfunc bar(ch chan&lt;- bool) {\n    for i := 0; i &lt; 5; i++ {\n        fmt.Println(\"Bar:\", i)\n        time.Sleep(100 * time.Millisecond)\n    }\n    ch &lt;- true\n}\n\nfunc main() {\n    // Define a channel\n    ch := make(chan bool)\n\n    // Start the operations in parallel\n    go foo(ch)\n    go bar(ch)\n\n    // Wait for completion\n    &lt;-ch\n    &lt;-ch\n\n    fmt.Println(\"Done!\")\n}\n</code></pre></p> <p>\u26a0\ufe0f This would not be the proper way to solve the problem (actually the Wait Group example would be the more appropriate way). This is just meant to demonstrate the usage of a channel.</p> <p>This library will likely prevent you to often need to utilise <code>channels</code>. It is key, however, to understand this mechanism and its important role on implementing synchronisation. </p>"},{"location":"a-golang-primer/#more-on-channels","title":"More on channels","text":"<p>Take the following naive example to compute values in parallel, using a channel to communicate back the result:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    // a wait group to wait for all results\n    var wg sync.WaitGroup\n\n    // a channel to pass by resuld\n    ch := make(chan int)\n\n    // launch 5 goroutines for calculating the square route of a number\n    for i := 0; i &lt; 5; i++ {\n        wg.Add(1) // inform the wait group we have one more execution to await for\n        go func(n int) {\n            ch &lt;- n * n // send the squared value of n through the channel\n            wg.Done() // signal that this goroutine is done\n        }(i)\n    }\n\n    // wait, in the background, for all calculations to finish before closing the channel\n    go func() {\n        wg.Wait() // wait for all goroutines to finish\n        close(ch) // close the channel\n    }()\n\n    // print results\n    for val := range ch {\n        fmt.Println(val)\n    }\n}\n</code></pre> <p>Though still academic, this example should give you a better understanding about the role of channel and of a Wait Group. </p>"},{"location":"a-golang-primer/#switch-case-statement-on-steroids","title":"Switch case statement on steroids","text":"<p>In Go, the switch statement is a versatile control structure, with unique features that familiarity with other languages might leave  one at loss when having a first contact. The keyword is <code>select</code> and this is the least odd difference one might spot.</p> <p>Take the following example, many other languages offer equivalent behavior:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    name := \"Gopher\"\n    switch name {\n    case \"Gopher\":\n        fmt.Println(\"Hello, Gopher!\")\n    case \"World\":\n        fmt.Println(\"Hello, World!\")\n    default:\n        fmt.Println(\"Hello, stranger!\")\n    }\n}\n</code></pre> <p>What makes Go special is the capability of dealing with channels, so this statement is crucial to work with such data structures.</p> <p>Take the following example: <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    ch1 := make(chan string)\n    ch2 := make(chan int)\n    ch3 := make(chan bool)\n\n    go func() {\n        defer close(ch1)\n        ch1 &lt;- \"Hello\"\n    }()\n\n    go func() {\n        defer close(ch2)\n        ch2 &lt;- 42\n    }()\n\n    ch1Closed := false\n    ch2Closed := false\n\n    defer close(ch3)\n\n    // when the count reach 0, cancel the context\n    go func() {\n        for {\n            if ch1Closed &amp;&amp; ch2Closed {\n                break\n            }\n        }\n\n        ch3 &lt;- true\n    }()\n\n    for {\n        select {\n        case msg, ok1 := &lt;-ch1:\n            if ok1 {\n                fmt.Println(\"Received number from ch1:\", msg)\n            } else {\n                fmt.Println(\"Channel 1 closed\")\n                ch1Closed = true\n            }\n        case num, ok2 := &lt;-ch2:\n            if ok2 {\n                fmt.Println(\"Received number from ch2:\", num)\n            } else {\n                fmt.Println(\"Channel 2 closed\")\n                ch2Closed = true\n            }\n        case &lt;-ch3:\n            fmt.Println(\"All channels closed\")\n            return\n        }\n    }\n}\n</code></pre></p> <p>In a nutshell, the previous example uses two channels to send messages and when both are closed we send another message to stop the execution.</p> <p>\u26a0\ufe0f Notice how it can be verified when a channel becomes closed and how he are using it to toggle the flags.</p> <p>One might consider using a counter, keeping track of the open channels, when reaching 0 it could be utilised to signal termination. You might be surprised that the messages stating that a channel got called can be called multiple times. Be aware of this behavior!</p> <p>Also, please understand this is just for illustrating purposes, it would not be a good implementation of a Parallel Aggregation pattern, neither the proper way to deal with cancellation.</p>"},{"location":"a-golang-primer/#context","title":"Context","text":"<p>In a nutshell, the standard data structure <code>context.Context</code> is essential to manage the lifecycle of long-running operations. It is very versatility and heavily used by this library.</p> <p>This section does not intend to be exhaustive in the topic, only bring awareness to key aspects.</p>"},{"location":"a-golang-primer/#cancellation","title":"Cancellation","text":"<p>Dealing with cancellation is paramount to EDT and the most relevant use cases are: - Timeouts / Deadline enforcement - Graceful shutdown</p>"},{"location":"a-golang-primer/#timeouts-deadline-enforcement","title":"Timeouts / Deadline enforcement","text":"<p>The distinction between a timeout and deadline is that the latter is defined by an exact point in time for it to be enforced, rather than setting a duration that must elapse for the cancellation condition to be met.  For time based cancellation this library offers constructs that assist on this concept (e.g. <code>Expirable</code> and <code>Delayable</code>).</p> <p>A timeout based cancellation: <pre><code>parent := context.Background()\nctx, cancel := context.WithTimeout(parent, 10*time.Second)\ndefer cancel()\n</code></pre></p> <p>A deadline based cancellation: <pre><code>parent := context.Background()\nctx, cancel := context.WithDeadline(parent, time.Now().Add(10*time.Second))\ndefer cancel()\n</code></pre></p> <p>Effectively both samples have equivalent behavior (it is just a matter of expressiveness that might best fit a use case or another).</p>"},{"location":"a-golang-primer/#graceful-shutdown","title":"Graceful shutdown","text":"<p>This behavior can be achieved by hooking the <code>os.Interrupt</code>, the standard library provides a convenient decorator that does exactly that:</p> <p><pre><code>ctx, cancel := context.WithSignal(context.Background(), os.Interrupt)\ndefer cancel()\n</code></pre> This library provides you a construct (<code>Director</code>) that assists with this responsibility, but it is important to be aware about this recipe in case you have a strong reason for not propagating the scope.</p>"},{"location":"a-golang-primer/#data-propagation","title":"Data Propagation","text":"<p>In Go, the <code>context.Context</code> fulfils an important role by providing a standard way to propagate request-scoped values (or just call it data) across different parts of a program. There are plenty of use cases where this mechanism can be of use to avoid passing down explicit parameters with specific types across multiple layers so a parameter can be of utilised only on a limited or even single pipeline execution stage (e.g. image getting an authenticate user on a HTTP request, passing it down as a context so a certain authorization verification can be made at a certain Service).</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n)\n\nfunc main() {\n    ctx := context.WithValue(context.Background(), \"userID\", \"42\")\n\n    doSomething(ctx)\n}\n\nfunc doSomething(ctx context.Context) {\n    userID, ok := ctx.Value(\"userID\").(string)\n\n    if !ok {\n        log.Println(\"No user defined\")\n        return\n    }\n\n    log.Println(\"Doing something for user\", userID)\n}\n</code></pre> <p>\ud83d\udc49 This library offers you a construct, the <code>Injector</code>, that rely on this very same mechanism. You will get, however, a more convenient and powerful way to retrieve values from your context, by satisfying dependencies. </p>"},{"location":"a-golang-primer/#handling-time","title":"Handling Time","text":"<p>There are certainly a lot to say about handling \"Time\" in Go, but we will only focus on the key aspects that matter most for EDT.</p>"},{"location":"a-golang-primer/#duration","title":"Duration","text":"<p>A duration (or <code>time.Duration</code>) is utilised to express a length of time that can perhaps represent a delay or a timeout (depending on the context it is applied). This standard data structure has a key part in most of EDT's constructs.</p> <p>If passing down hardcoded values you will be doing expressions like:  - <code>100 * time.Millisecond</code> (100ms)  - <code>5 * time.Decond</code> (5s)</p> <p>What might be something you need to do, that might not be easy to remember is doing the same but with a variable (lets say you refactor your code and instead of the hardcoded value you start using an environment variable for it).</p> <p>Take the following snippet: <pre><code>import \"time\"\n\nvar durationInSeconds int = 5\nduration := time.Duration(durationInSeconds) * time.Second\n</code></pre></p>"},{"location":"a-golang-primer/#delay","title":"Delay","text":"<p>If enforcing a delay, on a certain behavior you are better avoiding, most of the time, the usage of <code>time.Sleep</code> due to its blocking nature of the goroutine. Prefer the usage of <code>time.After</code> instead, since it relies on a channel that you can combine with other channels and, most importantly, a cancellation context.</p> <p>This technique is relevant for dealing properly with graceful (and quick) shutdowns of your application.</p> <p>Take the following example: <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    // Create a cancellation context with a timeout of 2 seconds\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    defer cancel()\n\n    fmt.Println(\"Starting the timer\")\n\n    // Wait for either the context to be cancelled or the timer to expire\n    select {\n    case &lt;-ctx.Done():\n        fmt.Println(\"Cancelled:\", ctx.Err())\n    case &lt;-time.After(5 * time.Second):\n        fmt.Println(\"Timer expired\")\n    }\n}\n</code></pre></p> <p>\ud83d\udc49 This library will assist you in common patterns dealing with time delays facilitating the usage of context propagation.</p>"},{"location":"action/","title":"Action","text":"<p>This simple Construct is the glue that makes most all other Constructs work together. Without being too opinionated, your functions just have to follow a simple convention, in order to have them injected as callbacks.</p> <p><pre><code>func(ctx context.Context) (Result, error) {\n    return nil, nil\n}\n</code></pre> Can be written as:</p> <pre><code>func(ctx context.Context) (Result, error) {\n    return action.Nothing()\n}\n</code></pre> <p>Which in turn is the same as:</p> <pre><code>action.DoNothing()\n</code></pre> <p>Most other Constructs have operations with this very same signature. </p> <p>\ud83d\udc49 That's the magic sauce that allows them to be chained together.</p>"},{"location":"actor/","title":"Actor","text":"<p>\ud83d\udea7</p>"},{"location":"cancellable/","title":"Cancellable","text":"<p>\ud83d\udea7</p>"},{"location":"delayable/","title":"Delayable","text":"<p>\ud83d\udea7</p>"},{"location":"director/","title":"Director","text":"<p>\ud83d\udea7</p>"},{"location":"event/","title":"Event","text":"<p>This is a very simple Construct that has one very important purposed of claiming that anything can be an Event:</p> <pre><code>type Event interface{}\n</code></pre> <p>Like an <code>Action</code>, the Event work as a glue for Event oriented Constructs:  - Event Hub  - State Machine</p>"},{"location":"event/#named-events","title":"Named Events","text":"<p>Normally you should not care much about the Name, nevertheless a <code>State Machine</code> has states names that you might have some trouble getting from a struct name. This gives you freedom of naming in return of implementing the <code>NamedEvent</code> interface.</p> <p>\ud83d\udc49 The <code>State Machine</code> constructs leverages from named events.</p> <p>e.g.:</p> <pre><code>hub.Publish(*event.WithName(\"SomeEvent\"), nil)\n</code></pre>"},{"location":"event/#key-values","title":"Key Values","text":"<p>Another option to define your own specific type, containing fields for passing parameters during the event publishing is to use a <code>GenericNamedEvent</code>.</p> <p>e.g.: <pre><code>hub.Publish(*event.WithNameAndKeyValues(\"SomeEvent\", \"Message\", 42), nil)\n</code></pre></p>"},{"location":"eventhub/","title":"Event Hub","text":"<p>This is the construct that alone justifies the name for this library. It allows the definition of events, where a <code>struct</code> represents a unique type. An instance of this <code>struct</code> can then be <code>Published</code> into the <code>EventHub</code>, which in turn will be notifying all <code>Subscribers</code> listening to that event.</p> <p>There are two ways of getting notified: - As an <code>Action</code> - As a <code>Handler</code></p> <p>The <code>EventHub</code> deals only with <code>Handlers</code> which will be the most optimal choice since <code>Actions</code> will be wrapped as the former. However, you are encouraged to use <code>Actions</code> because they will make the code easier to understand and more maintainable. Consider <code>Handlers</code> for advanced use cases.</p> <p>Events can contain data that will be passed down to the <code>Subscribers</code>.</p>"},{"location":"eventhub/#usage","title":"Usage","text":"<p>Assuming an event: <pre><code>type SomeEvent struct {  \n    SomeValue string  \n}\n</code></pre></p> <p>This code prints <code>42</code>: <pre><code>hub := eventhub.NewEventHub(nil)  \n\n\nhub.Subscribe(SomeEvent{}, func(ctx context.Context) (action.Result, error) {  \n    ev, _ := event.Get[SomeEvent](ctx)  \n    result = ev.SomeValue\n\n    fmt.Print(result)\n\n    return action.Nothing()  \n})  \n\nhub.Publish(SomeEvent{SomeValue: \"42\"}, nil)\n</code></pre></p>"},{"location":"executor/","title":"Executor","text":"<p>\ud83d\udea7</p>"},{"location":"expectable/","title":"Expectable","text":"<p>This construct can be seen as a higher level abstraction for synchronizing tasks. Using native Go language constructs it is not that difficult to make such orchestration with a <code>channel</code> or a <code>sync.WaitGroup</code> </p> <p>These native constructs, though undeniably powerful, can quickly produce messy and/or complex code. You get the chance to express this same pattern but taking advantage of <code>Events</code> and the <code>Event Hub</code>.</p> <p>In a nutshell you can block your execution until an <code>Event</code> is <code>Published</code>.</p> <p>\ud83d\udc49 You can set a timeout and a criteria for filtering a specific Event configuration.</p>"},{"location":"expectable/#usage","title":"Usage","text":"<pre><code>expectable.NewBuilder().\n    On(hub).\n    Expect(SomeEvent{}).\n    Do(context.Background())\n</code></pre> <p>The code above will block until <code>SomeEvent</code> gets published.</p> <pre><code>hub.Publish(SomeEvent{}, ctx)\n</code></pre>"},{"location":"expectable/#retrieving-event-values","title":"Retrieving event values","text":"<p>The result value, after unblocking is the event type itself. You can use this mechanism to pass parameters further down into your logic.</p> <pre><code>type SomeEvent struct {\n    Message string\n}\n\n...\n\nres, err := expectable.NewBuilder().\n    On(hub).\n    Expect(SomeEvent{}).\n    Do(context.Background())\n\n...\n\nif res.(SomeEvent).Message == \"Hello EDT!\" {\n\n}\n</code></pre>"},{"location":"expectable/#filtering-specific-event-values","title":"Filtering specific event values","text":"<p>You can target a specific event configuration that unlocks execution.</p> <pre><code>type SomeEvent struct {\n    Message string\n}\n\n...\n\nres, err := expectable.NewBuilder().\n    On(hub).\n    Expect(SomeEvent{}).\n    Where(func(e event.Event) bool {\n        if e.(SomeEvent).Message == \"Hello EDT!\" {\n            return true\n        }\n\n        return false\n    }).\n    Do(context.Background())\n}\n</code></pre> <p>The example above will only unlock with an event message containing <code>Hello EDT!</code>.</p> <p>\ud83d\udc49 You can also combine this scenario with a Timeout.</p>"},{"location":"expectable/#cancellation","title":"Cancellation","text":"<p>Another way to unblock execution is using context cancellation.</p> <pre><code>ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\ndefer cancel()\n\nres, err := expectable.NewBuilder().\n    On(hub).\n    Expect(SomeEvent{}).\n    Do(ctx)\n\nif err != nil {\n    // Deal with cancellation\n}\n</code></pre>"},{"location":"expectable/#timeout","title":"Timeout","text":"<p>You can directly specify a timeout as a limit for receiving an event.</p> <pre><code>ctx := context.Background()\n\nres, err := expectable.NewBuilder().\n    On(hub).\n    Expect(SomeEvent{}).\n    WithTimeout(1 * time.Second).\n    Do(ctx)\n\nif err != nil {\n    // Deal with the timeout\n}\n</code></pre>"},{"location":"expirable/","title":"Expirable","text":"<p>\ud83d\udea7</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#importing","title":"Importing","text":"<pre><code>go get -u github.com/a-inacio/edt-go\n</code></pre>"},{"location":"getting-started/#exploring-the-constructs","title":"Exploring the Constructs","text":"<p>This library implements a bunch of \"Design Patterns\", so you will want to understand their roles and how they fit together in order to leverage from this toolkit. Maybe using the term \"Design Pattern\" is a bit abusive, so we will be referring to \"Constructs\" instead from now on.</p>"},{"location":"getting-started/#creational","title":"Creational","text":"<p>These Constructs have the primary purpose of bridging your code with other Constructs:</p> <ul> <li>Action</li> <li>Event</li> <li>Injector</li> </ul> <p>\ud83d\udc49 You can also see them as a glue the chain Constructs together. </p>"},{"location":"getting-started/#behavioral","title":"Behavioral","text":"<p>These Constructs will help you on specific scenarios where you want to have your code behaving in a certain way:</p> <ul> <li>Actor</li> <li>Executor</li> <li>Delayable</li> <li>Director</li> <li>Event Hub</li> <li>State Machine</li> </ul>"},{"location":"getting-started/#concurrency","title":"Concurrency","text":"<p>These Constructs will help you on specific scenarios where you need to deal with asynchronous operations:</p> <ul> <li>Cancellable</li> <li>Expectable</li> <li>Expirable</li> <li>Promise</li> </ul>"},{"location":"getting-started/#construct-builders","title":"Construct Builders","text":"<p>Some Constructs offer a Builder method, this is the preferable way of instantiating such objects, since it will hide complexity of setting them up (you will learn that some have different options that affect behavior).</p> <p>Take the following example:</p> <pre><code>res, err := expirable.NewBuilder().\n    FromOperation(func(ctx context.Context) (action.Result, error) {\n        operationCalled = true\n\n        return awaitable.RunAfter(ctx, 5*time.Second, func(ctx context.Context) (action.Result, error) {\n            return 42, nil\n        })\n    }).\n    WithTimeout(10 * time.Second).\n    Do(ctx)\n</code></pre> <p>The code above sets up an <code>Expirable</code>, using the <code>Builder</code> method, that will wait up to <code>10 seconds</code> to execute a task. The task is just an <code>Awaitable</code> (a simple Construct) that will return <code>42</code> after <code>5 seconds</code> elapse. </p> <p>\ud83d\udc49 Simpler Constructs do not offer a Builder method, because there would not be added value with the extra verbosity.</p>"},{"location":"getting-started/#conventions","title":"Conventions","text":""},{"location":"getting-started/#if-it-has-a-do-then-it-is-implicitly-an-action","title":"If it has a <code>Do</code>, then it is implicitly an action","text":"<p>Some of the constructs allow combinations like: chaining, referencing or wrapping <code>actions</code>. Since this library has a philosophy around this loose concept (it is just a function with a specific, yet simple signature) all constructs that can result of an execution of \"something\", have a method named <code>Do</code> that respects this convention. It becomes, then, very simple to implement the aforementioned combinations.</p>"},{"location":"getting-started/#if-it-has-must-in-the-name-it-means-it-can-panic","title":"If it has <code>Must</code> in the name, it means it can <code>panic</code>","text":"<p>This library has a very strict usage of <code>panic</code>, so the developer can use it with peace of mind, not worrying about schizophrenic behavior resulting from misusage.</p> <p>Nevertheless, in some application designs, it is desirable to fully halt execution if certain fatal conditions occur. Some examples, where crashing is often preferable: - Dealing with unsatisfied dependencies. - Missing mandatory configuration step (e.g. initialize a config file with credentials that can then be used as a dependency by the application).</p> <p>\u26a1\ufe0f The developer can detect early mistakes or the application prevented to cause damage due to missing or wrong configurations. If using such a strategy, it is often best if fatal conditions are checked at early startup times. Evidently, each application design will have its own perks, you might want to allow it to run long enough to set up logging or leave a dead man letter behind.</p> <p>To avoid the typical <code>Go</code> code that tests for an error and then <code>panics</code>, this library conventions that any method that is prefixed with <code>Must</code> will terminate program execution in case of an error.</p>"},{"location":"injector/","title":"Injector","text":"<p>This construct allows you to append context information to any <code>Action</code> execution, by implementing a <code>Dependency Injection</code> pattern.</p> <p>\ud83d\udc49 If it is a Global or a Local context, it is up to you.</p> <p>It only relies on Go's standard <code>context.Context</code> so, as long as you keep track of if it (something you should be doing anyway) your contextual information will be easily accessible.</p> <p>\ud83d\udc49 Actually it means you are not limited only to these library's constructs it can be utilised standalone.</p>"},{"location":"injector/#usage","title":"Usage","text":""},{"location":"injector/#setting-values","title":"Setting Values","text":"<p>There are two distinct creational patterns at play here:</p> <ul> <li>Singleton</li> <li>Factory</li> </ul>"},{"location":"injector/#singleton-instance","title":"Singleton Instance","text":"<p>An instance must be given, and it will be the same every time it is retrieved.</p> <pre><code>dependencies := injector.WithContext(nil)\ndependencies.SetSingleton(SomeValue{message: \"42\"})\n</code></pre> <p>It is possible to define a constructor method (i.e. a function), this function is guaranteed to invoked only once.</p> <pre><code>dependencies := injector.WithContext(nil)\ndependencies.SetSingleton(func() SomeValue {\n    return SomeValue{message: \"42\"}\n})\n</code></pre> <p>The constructor method can have parameters as long as they can be satisfied by the injector:</p> <pre><code>dependencies := injector.WithContext(nil)\ndependencies.SetSingleton(func() SomeValue{\n    return SomeValue{message: \"42\"}\n})\n\ndependencies.SetSingleton(func(value SomeValue) AnotherValue {\n    return AnotherValue{message: value.message}\n})\n</code></pre>"},{"location":"injector/#factory","title":"Factory","text":"<p>A callback function is to be utilised, and you should be creating a new instance on each invocation.</p> <pre><code>dependencies := injector.WithContext(nil)\n\ncounter := 0\ndependencies.SetFactory(func() SomeValue {\n    counter++\n    return SomeValue{counter: counter}\n})\n</code></pre>"},{"location":"injector/#functions-limitations","title":"Functions limitations","text":"<p>\u26a0\ufe0f Though functions can have 0 or more arguments, they must have one and only one return type.</p>"},{"location":"injector/#retrieving-values","title":"Retrieving Values","text":"<p>Independently of the injected dependency's creational design pattern type (Singleton or Factory), you get the values in the same manner.</p> <pre><code>value, err := injector.GetValue[SomeValue](dependencies)\n\nif err != nil {\n    // do something with `value`\n}\n</code></pre>"},{"location":"injector/#satisfying-interfaces","title":"Satisfying Interfaces","text":"<p>Not withstanding the type creational pattern, when retrieving a value by interface the injector will either look for an explicit definition of an interface dependency or it will look for all the known types and find the ones that implement such interface.</p> <p>This process only succeeds if there is exactly one resolution for the target type  interface.</p> <pre><code>value, err := injector.GetValue[SomeInterface](dependencies)\n\nif err != nil {\n    // do something with `value`\n}\n</code></pre>"},{"location":"injector/#resolving-functions","title":"Resolving Functions","text":"<p>As an alternative, to explicitly set a factory for every single entity of your application, you can manually control this flow by resolving said functions manually. The same constraints of Factory methods apply. </p> <pre><code>value, err := injector.Resolve[AnotherValue](\n    dependencies, \n    func(value SomeValue) AnotherValue {  \n        return AnotherValue{message: value.message}  \n    })\n\nif err != nil {\n    // do something with `value`\n}\n</code></pre>"},{"location":"loopable/","title":"Loopable","text":"<p>Use this constructs to keep something running forever. Execution can be canceled using a <code>context</code>.</p>"},{"location":"loopable/#usage","title":"Usage","text":"<pre><code>loopable.RunForever(context.Background(), 5*time.Second, func(ctx context.Context) (action.Result, error) {\n    fmt.Println(\"Hello World! See you in a moment again soon \ud83d\udc4b\")\n    return action.Nothing()\n})\n</code></pre>"},{"location":"loopable/#cancellation","title":"Cancellation","text":"<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\ndefer cancel()\n\nloopable.RunForever(ctx, 5*time.Second, func(ctx context.Context) (action.Result, error) {\n    fmt.Println(\"Hello World! Will only be called once \ud83d\udc4b\")\n    return action.Nothing()\n})\n</code></pre>"},{"location":"promise/","title":"Promise","text":"<p>\ud83d\udea7</p>"},{"location":"statemachine/","title":"State Machine","text":"<p>\ud83d\udea7</p>"}]}